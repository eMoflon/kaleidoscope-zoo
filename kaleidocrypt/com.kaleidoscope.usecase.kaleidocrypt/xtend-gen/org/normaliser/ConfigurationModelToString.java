package org.normaliser;

import CryptoAPIConfig.Algorithm;
import CryptoAPIConfig.Digest;
import CryptoAPIConfig.KeyDerivationAlgorithm;
import CryptoAPIConfig.SymmetricBlockCipher;
import CryptoAPIConfig.Task;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.normaliser.AlgorithmNormaliser;
import org.normaliser.ImportNormaliser;

@SuppressWarnings("all")
public class ConfigurationModelToString {
  private ImportNormaliser importNormaliser = new ImportNormaliser();
  
  private AlgorithmNormaliser algorithmNormaliser = new AlgorithmNormaliser();
  
  public ConfigurationModelToString() {
  }
  
  public CharSequence unparseTask(final Task task) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("task {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("package: �task.package�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("description: �task.description�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("algorithms: [");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�val List<Algorithm> sortedAlgorithms = new ArrayList<Algorithm>(task.algorithms)�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�algorithmNormaliser.normalize(sortedAlgorithms)�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�FOR a : sortedAlgorithms�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�unparseAlgorithm(a)�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�ENDFOR�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("]\t\t\t\t\t\t");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence unparseAlgorithm(final Algorithm alg) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�IF alg instanceof SymmetricBlockCipher�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�unparseSymmetricBlockCipher(alg)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�ENDIF�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�IF alg instanceof KeyDerivationAlgorithm�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�unparseKeyDerivationAlgorithm(alg)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�ENDIF�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�IF alg instanceof Digest�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�unparseDigestAlgorithm(alg)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�ENDIF�");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence unparseSymmetricBlockCipher(final SymmetricBlockCipher sbc) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("algorithm {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("description: �sbc.description�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("name: �sbc.name�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("security: �sbc.security�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("performance: �sbc.performance�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("mode: �sbc.mode�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("padding: �sbc.padding�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("keySize: �sbc.keySize�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("incldues: [");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�val List<Algorithm> sortedAlgorithms = new ArrayList<Algorithm>(sbc.includes)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�algorithmNormaliser.normalize(sortedAlgorithms)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�FOR a : sortedAlgorithms�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�unparseAlgorithm(a)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�ENDFOR�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("imports: [");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�val List<Import> sortedImports = new ArrayList<Import>(sbc.imports)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�importNormaliser.normalize(sortedImports)�\t\t\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�FOR i : sortedImports�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("import �i.value�;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�ENDFOR�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("}\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence unparseKeyDerivationAlgorithm(final KeyDerivationAlgorithm kda) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("algorithm {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("description: �kda.description�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("name: �kda.name�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("security: �kda.security�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("performance: �kda.performance�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("iterations: �kda.iterations�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("outputSize: �kda.outputSize�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("incldues: [");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�val List<Algorithm> sortedAlgorithms = new ArrayList<Algorithm>(kda.includes)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�algorithmNormaliser.normalize(sortedAlgorithms)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�FOR a : sortedAlgorithms�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�unparseAlgorithm(a)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�ENDFOR�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("imports: [");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�val List<Import> sortedImports = new ArrayList<Import>(kda.imports)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�importNormaliser.normalize(sortedImports)�\t\t\t\t\t");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�FOR i : sortedImports�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("import �i.value�;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�ENDFOR�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("}\t");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence unparseDigestAlgorithm(final Digest digest) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("algorithm {");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("description: �digest.description�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("name: �digest.name�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("security: �digest.security�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("performance: �digest.performance�\t\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("outputSize: �digest.outputSize�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("incldues: [");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�val List<Algorithm> sortedAlgorithms = new ArrayList<Algorithm>(digest.includes)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�algorithmNormaliser.normalize(sortedAlgorithms)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�FOR a : sortedAlgorithms�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�unparseAlgorithm(a)�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�ENDFOR�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("]");
    _builder.newLine();
    _builder.append("}\t");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
}

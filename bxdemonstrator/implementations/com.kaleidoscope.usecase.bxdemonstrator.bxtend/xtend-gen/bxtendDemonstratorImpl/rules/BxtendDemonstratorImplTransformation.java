package bxtendDemonstratorImpl.rules;

import bxtendDemonstratorImpl.rules.Elem2Elem;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;

public class BxtendDemonstratorImplTransformation {
  private Resource sourceModel;
  
  private Resource targetModel;
  
  private Resource corrModel;
  
  private /* List<Elem2Elem> */Object rules /* Skipped initializer because of errors */;
  
  public final static /* String */Object FWD_DIRECTION = "FWD";
  
  public final static /* String */Object BWD_DIRECTION = "BWD";
  
  public final static /* String */Object item2FirstBlock = "item2FirstBlock";
  
  public final static /* String */Object item2SecondBlock = "item2SecondBlock";
  
  public final static /* String */Object grid2Kitchen = "Grid2Kitchen";
  
  public final static /* String */Object socket2Group = "socket2Group";
  
  public BxtendDemonstratorImplTransformation(final URI source, final URI target, final URI correspondence) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field size is undefined for the type EList<EObject>"
      + "\nThe method add(Object) is undefined for the type EList<EObject>"
      + "\n== cannot be resolved"
      + "\neINSTANCE cannot be resolved"
      + "\ncreateTransformation cannot be resolved");
  }
  
  public BxtendDemonstratorImplTransformation(final Resource source, final Resource target, final Resource correspondence) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field size is undefined for the type EList<EObject>"
      + "\nThe method add(Object) is undefined for the type EList<EObject>"
      + "\n== cannot be resolved"
      + "\neINSTANCE cannot be resolved"
      + "\ncreateTransformation cannot be resolved");
  }
  
  /**
   * Fuegt alle Regeln zum rules-Set hinzu. Sollte im Konstruktor aufgerufen werden.
   */
  private void addRules() {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method isEmpty() is undefined for the type EList<EObject>"
      + "\nThe method add(Object) is undefined for the type EList<EObject>"
      + "\nThe field BxtendDemonstratorImplTransformation.rules refers to the missing type List"
      + "\nThe field BxtendDemonstratorImplTransformation.rules refers to the missing type List"
      + "\nThe field BxtendDemonstratorImplTransformation.rules refers to the missing type List"
      + "\neINSTANCE cannot be resolved"
      + "\ncreateTransformation cannot be resolved"
      + "\nadd cannot be resolved"
      + "\nadd cannot be resolved"
      + "\nadd cannot be resolved");
  }
  
  public void sourceToTarget() {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field size is undefined for the type EList<EObject>"
      + "\nThe field BxtendDemonstratorImplTransformation.rules refers to the missing type List"
      + "\nThe method sourceToTarget(String) from the type Elem2Elem refers to the missing type String"
      + "\nThe method deleteUnreferencedTargetElements() from the type BxtendDemonstratorImplTransformation refers to the missing type Object"
      + "\n!= cannot be resolved");
  }
  
  public void targetToSource() {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field size is undefined for the type EList<EObject>"
      + "\nThe field BxtendDemonstratorImplTransformation.rules refers to the missing type List"
      + "\nThe method targetToSource(String) from the type Elem2Elem refers to the missing type String"
      + "\nThe method deleteUnreferencedSourceElements() from the type BxtendDemonstratorImplTransformation refers to the missing type Object"
      + "\n!= cannot be resolved");
  }
  
  public boolean checkCorrespondences() {
    return true;
  }
  
  public Object detectSourceDeletions() {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method filter(java.lang.Class) is undefined for the type TreeIterator<EObject>"
      + "\nThe method or field sourceElement is undefined for the type Object"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nfilter cannot be resolved"
      + "\n== cannot be resolved");
  }
  
  public Object detectTargetDeletions() {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method filter(java.lang.Class) is undefined for the type TreeIterator<EObject>"
      + "\nThe method or field targetElement is undefined for the type Object"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nfilter cannot be resolved"
      + "\n== cannot be resolved");
  }
  
  public Object deleteUnreferencedTargetElements() {
    throw new Error("Unresolved compilation problems:"
      + "\nList cannot be resolved to a type."
      + "\nThe method or field newArrayList is undefined"
      + "\nThe method or field targetElement is undefined for the type Object"
      + "\nThe method or field EcoreUtil is undefined"
      + "\nThe method detectSourceDeletions() from the type BxtendDemonstratorImplTransformation refers to the missing type Object"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nforEach cannot be resolved"
      + "\n+= cannot be resolved"
      + "\n+= cannot be resolved"
      + "\nforEach cannot be resolved"
      + "\ndelete cannot be resolved");
  }
  
  public Object deleteUnreferencedSourceElements() {
    throw new Error("Unresolved compilation problems:"
      + "\nList cannot be resolved to a type."
      + "\nBlock cannot be resolved to a type."
      + "\nThe method or field newArrayList is undefined"
      + "\nThe method or field sourceElement is undefined for the type Object"
      + "\nThe method or field sourceElement is undefined for the type Object"
      + "\nThe method or field EcoreUtil is undefined"
      + "\nThe method detectTargetDeletions() from the type BxtendDemonstratorImplTransformation refers to the missing type Object"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nforEach cannot be resolved"
      + "\n+= cannot be resolved"
      + "\n+= cannot be resolved"
      + "\nforEach cannot be resolved"
      + "\ndelete cannot be resolved");
  }
}
